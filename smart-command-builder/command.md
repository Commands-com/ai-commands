# Smart Command Builder
---
description: >
  Intelligent command generator that creates complete Commands.com-compatible commands
  from task descriptions. Analyzes available MCP servers to recommend optimal combinations,
  generates proper commands.yaml entries, and creates all necessary files for immediate
  Commands.com integration via GitHub.
allowed_tools:
  - commands-com-mcp-demo-server    # MCP discovery and Commands.com integration
  - filesystem                     # File creation and directory management
---

## Arguments

```
/build-command 
task_description="<describe what you want the command to do>"
[command_name=<auto-generated|custom-name>]
[category=<auto|development|content-creation|api-tools|security-audit>]
[complexity=<simple|medium|advanced>]
[include_examples=<yes|no>]
[learning_mode=<yes|no>]
```
*Defaults → `command_name=auto-generated  category=auto  complexity=medium  include_examples=yes  learning_mode=yes`*

### Example

```
/build-command 
task_description="Create a tool that scrapes website data and analyzes it for insights with database storage"
category=development
complexity=advanced
```

---

## Context – what the AI should do

1. **Parse Arguments and Initialize**
   * `task_description` - Core functionality the user wants
   * `command_name` - Generate kebab-case name or use provided
   * `category` - Auto-detect or use specified category
   * `complexity` - Determines feature richness and MCP selection
   * `include_examples` - Whether to generate usage examples
   * `learning_mode` - Whether to analyze existing patterns

2. **MCP Server Discovery and Selection**
   * Call `/mcp__commands-com-mcp-demo-server__get_mcp_servers` to get available MCPs
   * **Task Analysis**: Parse task description for keywords and requirements
   * **Smart MCP Matching**:
     - Web/scraping tasks → `puppeteer`, `filesystem`
     - Code analysis → `github`, `filesystem`, `sqlite`
     - API/data tasks → `filesystem`, `sqlite`
     - File processing → `filesystem`
     - Always add `filesystem` for file operations
   * **Complexity Considerations**:
     - Simple: 1-2 MCPs, basic functionality
     - Medium: 2-3 MCPs, moderate features
     - Advanced: 3-4 MCPs, comprehensive capabilities

3. **Command Structure Generation**
   * Call `/mcp__commands-com-mcp-demo-server__get_commands_yaml_guide` for proper formatting
   * Generate unique command name (kebab-case) if not provided
   * Auto-categorize based on task description and MCP selection
   * Create parameter schema based on task requirements

4. **Conflict Prevention and Validation**
   * Call `/mcp__commands-com-mcp-demo-server__list_assets` to check existing user commands
   * Ensure no naming conflicts with user's existing assets
   * Validate command name follows conventions (kebab-case, descriptive)

5. **Content Generation**
   * **command.md**: Complete command implementation following Commands.com patterns
     - Proper YAML frontmatter with description and allowed_tools
     - Arguments section with examples
     - Detailed step-by-step implementation context
     - MCP-specific function calls and workflows
   * **README.md**: User documentation with installation and usage
   * **Preview placeholder**: Note about thumbnail generation

6. **Commands.yaml Integration**
   * Read existing `/filesystem__read_file path=commands.yaml`
   * Parse current structure and metadata
   * Generate new command entry with all required fields
   * Update metadata (increment total_commands, update timestamp)
   * Write updated commands.yaml back to filesystem

7. **File System Operations**
   * Create command directory: `/filesystem__create_directory path=./{command-name}`
   * Write command.md: `/filesystem__write_file path=./{command-name}/command.md`
   * Write README.md: `/filesystem__write_file path=./{command-name}/README.md`
   * Update commands.yaml: `/filesystem__write_file path=./commands.yaml`

8. **Quality Assurance and Validation**
   * Call `/mcp__commands-com-mcp-demo-server__validate_commands_yaml` with generated YAML
   * Validate all generated files follow Commands.com specifications
   * Check for errors, warnings, and suggestions from validation
   * Retry generation if critical errors are found
   * Ensure proper markdown formatting and YAML structure

9. **Learning Mode (Optional)**
   * If `learning_mode=yes`, analyze patterns from existing commands
   * Look for similar task descriptions in trending commands
   * Adapt successful patterns to new command generation

10. **Final Output and Summary**
    * Generate summary of created files and validation results
    * Provide clear next steps: commit to GitHub, then manually import to Commands.com
    * Include any validation warnings or suggestions for improvement
    * Note that Commands.com only auto-updates existing commands, not new ones

> Focus on creating production-ready commands that follow Commands.com best practices. The generated command should be immediately usable and properly integrated into the existing command repository structure.